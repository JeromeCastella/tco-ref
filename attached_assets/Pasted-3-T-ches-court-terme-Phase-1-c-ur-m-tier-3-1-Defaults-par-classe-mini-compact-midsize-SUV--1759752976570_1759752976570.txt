3) Tâches à court terme (Phase 1 – cœur métier)
3.1 Defaults par classe (mini/compact/midsize/SUV)

But: pré-remplir l’UI avec des valeurs sourcées, et standardiser l’accès aux defaults.

Livrables

data/processed/defaults_by_class.json

tco_core/defaults.py (loader + accès par (tech, classe))

Exemple JSON (structure)

{
  "midsize": {
    "ICE": {
      "purchase_price": 42000,
      "residual_rate_8y_hint": 0.28,
      "consumption_fuel_l_per_100": 6.8,
      "maint_6y_chf": 3200,
      "tires_base_chf": 1000
    },
    "BEV": {
      "purchase_price": 55000,
      "residual_rate_8y_hint": 0.35,
      "consumption_elec_kwh_per_100": 17.0,
      "maint_6y_chf": 2800,
      "tires_base_chf": 1000
    },
    "PHEV": {
      "purchase_price": 52000,
      "residual_rate_8y_hint": 0.32,
      "consumption_fuel_l_per_100": 5.0,
      "consumption_elec_kwh_per_100": 16.0,
      "maint_6y_chf": 3000,
      "tires_base_chf": 1000
    }
  }
}


Tests
tests/test_defaults.py : vérifie qu’on charge, qu’on get par (tech, classe), et que l’app peuple bien les champs.

3.2 Valeur résiduelle (VR) — règle méthodo

But: calculer VR année N, avec “Retail 6y −10% relatif ⇒ extrapolation 8y”.

Livrables

tco_core/residual.py: residual_at_end(spec, years, method="bfe_2023") -> (vr_nominale, vr_actualisee)

Intégration: remplacer l’ajout VR dans tco_core/tco.py pour utiliser la VR nominale sur la dernière année, et l’actualiser pour la décomposition CAPEX net.

Tests
tests/test_residual.py : cas nominaux + bornes.

3.3 Maintenance 7/6 → 8 ans (méthodo)

But: remplacer l’uplift simpliste par la vraie règle de la doc (profil par année).

Livrables

tco_core/maintenance.py: maintenance_series(spec, params, years) retourne un profil annuel (inflation OPEX appliquée).

Utilisé dans tco_core/cashflows.py.

Tests
tests/test_maintenance.py : somme 6 ans vs 7/6 à 8 ans, inflation, bornes années.

3.4 Pneus (remplacements discrets)

But: passer d’une répartition linéaire à des remplacements discrets (ex: tous les X km), selon la classe.

Livrables

tco_core/tires.py: tires_series(spec, params, years) calcule les occurrences (km/an × années), applique inflation OPEX.

Tests
tests/test_tires.py : nombre de remplacements attendu, inflation, ×2 méthodo.

3.5 PHEV — part électrique & profil de recharge

But: calculer l’énergie PHEV comme un mix élec/thermique, où la part élec utilise le prix pondéré (Maison/Travail/Public).

Livrables

tco_core/cashflows.py: annual_energy_cost_phev() + utilisation de weighted_electricity_price() dans build_energy_price_series().

Tests
tests/test_cashflows.py : cas PHEV 0%, 50%, 100% élec; inflation énergie; cohérence unités.

4) UI/UX (Phase 2)

Expander “+ paramètres” complet (énergie, inflations, conso par techno, switches maintenance/pneus).

Profil de recharge : deux sliders + 3ᵉ auto, somme verrouillée à 100% avec caption.

Classe véhicule : select → charge defaults → hydrate l’UI (modifiable).

PHEV : slider part élec (0–100%) + tooltip sur prix pondéré.

Tests manuels :

Streamlit app: cohérence des champs, format CHF, responsive.

5) Dataviz & cohérence (Phase 3)

Bar chart par poste (Plotly):
Acquisition (achat – VR act.), Énergie act., Maintenance act., Pneus act., Autres act.
→ Label total au-dessus = |NPV|.

Courbe cumulée: axe Y commence à 0; markers; infobulles claires.

Table annuelle (BEV/ICE/PHEV): colonnes standard, export CSV.

Validation
validation.py + message UI si |NPV| ≠ somme postes (tolérance machine).

6) Données & scénarios (Phase 4)

data/examples/scenarios.csv: quelques scénarios (horizon, km/an, prix énergie).

(Option) runner scénarios pour comparer vite (tableau + export CSV).

7) Qualité & packaging (Phase 5)

Étoffer tests unitaires (VR, maintenance, pneus, PHEV, validation).

Retirer le hack sys.path → packaging local:

pyproject.toml (project + dependencies + tools black/isort/mypy/ruff)

pip install -e .

pre-commit (black/isort/ruff) et CI GitHub (pytest).

8) Déploiement (Phase 6)

Versions figées dans requirements.txt.

Déployer sur Streamlit Community Cloud (entry: app/app.py).

Badge “Open in Streamlit” dans README.

9) Contribution workflow

Créer branche par feature (feat/…, fix/…).

Petits PRs, tests verts, revue.

Merge → bump CHANGELOG minimal.

10) Points d’attention

Unités : BEV en CHF/kWh; ICE en CHF/L; conso en kWh/100 ou L/100.

Actualisation : flux année 0 = achat (non actualisé), flux années t=1..N actualisés par (1+r)^t.

Décomposition : la VR de fin est actualisée dans CAPEX net du bar chart; la NPV, elle, intègre la VR nominale comme flux en année N.

Tolérances : toujours comparer les absolus (|NPV|) pour l’égalité “somme postes”.